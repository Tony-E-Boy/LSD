------------------------------------------------------------------------------------------------------------------------
When Is the Session Created?
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
    We can control exactly when our session gets created and how Spring Security will interact with it:
(Мы можем точно контролировать, когда будет создана наша сессия и как Spring Security будет взаимодействовать с ней:)

1. always – a session will always be created if one doesn't already exist
                   (сеанс всегда будет создан, если он еще не существует)

2. ifRequired – a session will be created only if required (default)
                  (сеанс будет создан только в случае необходимости)

3. never – the framework will never create a session itself but it will use one if it already exists
(фреймворк никогда не создаст сеанс сам по себе но он будет использовать его если он уже существует)

4. stateless – no session will be created or used by Spring Security
     (никакой сеанс не будет создан или использован Spring Security)
------------------------------------------------------------------------------------------------------------------------
<http create-session="ifRequired">...</http>
Java configuration:

@Override
protected void configure(HttpSecurity http) throws Exception {
    http.sessionManagement()
        .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
}
------------------------------------------------------------------------------------------------------------------------
    Очень важно понимать, что эта конфигурация контролирует только то, что делает Spring Security, а не все приложение.
Spring Security может не создать сеанс, если мы проинструктируем его не делать этого, но наше приложение может!

По умолчанию Spring Security создает сеанс, когда он ему нужен – это “ifRequired".

Для более апатридного приложения опция “никогда " гарантирует, что Spring Security сама по себе не создаст никакого
сеанса; однако, если приложение создаст его, то Spring Security будет использовать его.

Наконец, самый строгий вариант создания сеанса - "без состояния" - является гарантией того, что приложение вообще
не создаст никакого сеанса.

Это было введено в Spring 3.1 и будет эффективно пропускать части цепочки фильтров безопасности Spring - в основном
связанные с сеансом части, такие как HttpSessionSecurityContextRepository, SessionManagementFilter, RequestCacheFilter.

Эти более строгие механизмы контроля имеют прямое отношение к тому, что файлы cookie не используются, и поэтому каждый
запрос должен быть повторно аутентифицирован. Эта архитектура без гражданства хорошо работает с API REST и их
ограничением безгражданства. Они также хорошо работают с механизмами аутентификации, такими как базовая(Basic) и
дайджест-аутентификация(Digest Authentication).

------------------------------------------------------------------------------------------------------------------------
Under the Hood
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
    Перед выполнением процесса аутентификации Spring Security запустит фильтр, отвечающий за хранение контекста безопасности
между запросами, - SecurityContextPersistenceFilter. Контекст будет храниться в соответствии со
стратегией-HttpSessionSecurityContextRepository по умолчанию-которая использует сеанс HTTP в качестве хранилища.